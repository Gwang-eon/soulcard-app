# ğŸ—ï¸ ê¸°ìˆ  ì•„í‚¤í…ì²˜ ë¬¸ì„œ

AI íƒ€ë¡œì¹´ë“œ ì•±ì˜ ì „ì²´ ê¸°ìˆ  êµ¬ì¡° ë° ì„¤ê³„ ì›ì¹™

## ğŸ“‹ ëª©ì°¨

1. [ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#ì „ì²´-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
2. [í•µì‹¬ ì»´í¬ë„ŒíŠ¸](#í•µì‹¬-ì»´í¬ë„ŒíŠ¸)
3. [ë°ì´í„° êµ¬ì¡°](#ë°ì´í„°-êµ¬ì¡°)
4. [API ì„¤ê³„](#api-ì„¤ê³„)
5. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
6. [í™•ì¥ì„± ì„¤ê³„](#í™•ì¥ì„±-ì„¤ê³„)

## ğŸ¯ ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ê³„ì¸µí˜• ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              í”„ë ˆì  í…Œì´ì…˜ ê³„ì¸µ                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Web Client  â”‚  â”‚ Mobile App      â”‚    â”‚
â”‚  â”‚ (HTML/CSS/JS)â”‚  â”‚ (React Native) â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ HTTP/REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ì„œë¹„ìŠ¤ ê³„ì¸µ                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Express Server  â”‚ â”‚ Tarot Reading   â”‚ â”‚
â”‚  â”‚ (API Gateway)   â”‚ â”‚ Service         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê³„ì¸µ               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚Combination  â”‚ â”‚ Card Loader        â”‚   â”‚
â”‚ â”‚Engine       â”‚ â”‚ (Singleton)        â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚Card         â”‚ â”‚ Question Analyzer  â”‚   â”‚
â”‚ â”‚Renderer     â”‚ â”‚ (AI/ML)           â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚JSON Files   â”‚ â”‚ TypeScript Types   â”‚   â”‚
â”‚ â”‚(Static Data)â”‚ â”‚ (Schema)          â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

1. **ë‹¨ì¼ ì±…ì„ ì›ì¹™ (SRP)**: ê° í´ë˜ìŠ¤ì™€ ëª¨ë“ˆì€ í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§
2. **ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ (DIP)**: ê³ ìˆ˜ì¤€ ëª¨ë“ˆì´ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ
3. **ì‹±ê¸€í†¤ íŒ¨í„´**: ë°ì´í„° ë¡œë”ì™€ ì—”ì§„ë“¤ì€ ì‹±ê¸€í†¤ìœ¼ë¡œ êµ¬í˜„
4. **íŒ©í† ë¦¬ íŒ¨í„´**: ì¹´ë“œì™€ ë¦¬ë”© ê°ì²´ ìƒì„±
5. **ì „ëµ íŒ¨í„´**: ë‹¤ì–‘í•œ ìŠ¤í”„ë ˆë“œ ë°©ì‹ êµ¬í˜„

## ğŸ”§ í•µì‹¬ ì»´í¬ë„ŒíŠ¸

### 1. CardLoader (ë°ì´í„° ë¡œë”)

```typescript
export class CardLoader {
  private static instance: CardLoader;
  private allCards: TarotCard[] = [];
  private isLoaded = false;

  // ì‹±ê¸€í†¤ íŒ¨í„´
  public static getInstance(): CardLoader {
    if (!CardLoader.instance) {
      CardLoader.instance = new CardLoader();
    }
    return CardLoader.instance;
  }

  // ì§€ì—° ë¡œë”©
  public async loadAllCards(): Promise<void> {
    if (this.isLoaded) return;
    // íŒŒì¼ ì‹œìŠ¤í…œ ë˜ëŠ” fetchë¥¼ í†µí•œ ë°ì´í„° ë¡œë“œ
  }
}
```

**ì£¼ìš” ê¸°ëŠ¥:**
- ğŸ“ ë¶„ì‚°ëœ JSON íŒŒì¼ì—ì„œ ì¹´ë“œ ë°ì´í„° ë¡œë“œ
- ğŸ’¾ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì‹±ê¸€í†¤ ê´€ë¦¬
- ğŸ”„ í™˜ê²½ë³„ ë¡œë”© ì „ëµ (Node.js vs Browser)
- ğŸ“Š ì‹¤ì‹œê°„ í†µê³„ ì œê³µ

### 2. CombinationEngine (ì¡°í•© ë¶„ì„ ì—”ì§„)

```typescript
export class CombinationEngine {
  // ì‹¤ì‹œê°„ ì¡°í•© ê°•ë„ ê³„ì‚°
  public calculateCombinationStrength(cards: TarotCard[]): Strength {
    let strengthScore = 0;
    
    // ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ ê°€ì¤‘ì¹˜
    const majorCount = cards.filter(card => card.suit === 'major').length;
    strengthScore += majorCount * 3;
    
    // íŠ¹ë³„ íŒ¨í„´ ë³´ë„ˆìŠ¤
    const specialBonus = this.getSpecialCombinationBonus(cards);
    strengthScore += specialBonus;
    
    // ê°•ë„ ë¶„ë¥˜ ì•Œê³ ë¦¬ì¦˜
    return this.classifyStrength(strengthScore);
  }
}
```

**í•µì‹¬ ì•Œê³ ë¦¬ì¦˜:**
- ğŸ¯ ì›ì†Œ ë¶„ì„ (Element Analysis)
- ğŸ”¢ ìˆ˜ì¹˜ íŒ¨í„´ ì¸ì‹ (Numerical Pattern Recognition)
- ğŸŒŸ íŠ¹ë³„ ì¡°í•© ê°ì§€ (Special Pattern Detection)
- ğŸ“ˆ ë™ì  ê°•ë„ ê³„ì‚° (Dynamic Strength Calculation)

### 3. TarotReadingService (ë¦¬ë”© ì„œë¹„ìŠ¤)

```typescript
export class TarotReadingService {
  // ì§ˆë¬¸ ë¶„ì„ AI
  public analyzeQuestion(question: string): QuestionAnalysis {
    const lowerQuestion = question.toLowerCase();
    
    // ì¹´í…Œê³ ë¦¬ ë¶„ì„
    let suggestedCategory: Category = 'general';
    if (lowerQuestion.includes('ì‚¬ë‘') || lowerQuestion.includes('ì—°ì• ')) {
      suggestedCategory = 'love';
    }
    // ... ì¶”ê°€ ë¶„ì„ ë¡œì§
    
    return {
      suggestedCategory,
      suggestedSpread,
      keywords: this.extractKeywords(question),
      emotion: this.analyzeEmotion(question),
      urgency: this.analyzeUrgency(question)
    };
  }
}
```

**AI/ML ê¸°ëŠ¥:**
- ğŸ§  ìì—°ì–´ ì²˜ë¦¬ (NLP)
- ğŸ­ ê°ì • ë¶„ì„ (Sentiment Analysis)
- ğŸ” í‚¤ì›Œë“œ ì¶”ì¶œ (Keyword Extraction)
- ğŸ“Š ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜ (Category Classification)

### 4. CardRenderer (ì¹´ë“œ ë Œë”ë§)

```typescript
export class CardRenderer {
  // ASCII ì•„íŠ¸ ì¹´ë“œ ìƒì„±
  private static createCardBox(card: TarotCard, isReversed: boolean): string {
    const orientation = isReversed ? 'ğŸ”„' : 'â¬†ï¸';
    const suitSymbol = this.getSuitSymbol(card.suit);
    
    return [
      'â”Œ' + 'â”€'.repeat(22) + 'â”',
      `â”‚ ${card.number || 0}`.padEnd(23, ' ') + 'â”‚',
      `â”‚ ${card.koreanName}`.padEnd(23, ' ') + 'â”‚',
      // ... ì¹´ë“œ êµ¬ì¡° ìƒì„±
      'â””' + 'â”€'.repeat(22) + 'â”˜'
    ].join('\n');
  }
}
```

**ë Œë”ë§ ê¸°ëŠ¥:**
- ğŸ¨ ASCII ì•„íŠ¸ ì¹´ë“œ ìƒì„±
- ğŸ“± ëª¨ë°”ì¼ ì•±ìš© ë°ì´í„° ë³€í™˜
- ğŸ­ ë‹¤ì–‘í•œ ë ˆì´ì•„ì›ƒ ì§€ì›
- ğŸŒˆ ìˆ˜íŠ¸ë³„ ìƒ‰ìƒ ì‹œìŠ¤í…œ

## ğŸ“Š ë°ì´í„° êµ¬ì¡°

### ë¶„ì‚° íŒŒì¼ ì‹œìŠ¤í…œ

```
data/
â”œâ”€â”€ cards/
â”‚   â”œâ”€â”€ majorArcana.json     # 22ì¥ (ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜)
â”‚   â”œâ”€â”€ wands.json          # 14ì¥ (ì™„ë“œ)
â”‚   â”œâ”€â”€ cups.json           # 14ì¥ (ì»µ)
â”‚   â”œâ”€â”€ swords.json         # 14ì¥ (ì†Œë“œ)
â”‚   â””â”€â”€ pentacles.json      # 14ì¥ (íœíƒ€í´)
â”œâ”€â”€ enums.json              # ì—´ê±°í˜• ì •ì˜
â”œâ”€â”€ majorArcanaElements.json # ì ì„±í•™ì  ì •ë³´
â””â”€â”€ cardCombinations.json   # íŠ¹ë³„ ì¡°í•© ë°ì´í„°
```

### TypeScript íƒ€ì… ì‹œìŠ¤í…œ

```typescript
// í•µì‹¬ íƒ€ì… ì •ì˜
export interface TarotCard {
  id: number;
  name: string;
  koreanName: string;
  suit: Suit;
  number?: number;
  element: Element;
  uprightKeywords: string[];
  reversedKeywords: string[];
  interpretations: {
    upright: CardInterpretations;
    reversed: CardInterpretations;
  };
  timing: CardTiming;
  advice: {
    upright: CardAdvice;
    reversed: CardAdvice;
  };
  symbolism: Symbol[];
  imageUrl: string;
}

// ê°•íƒ€ì… ì—´ê±°í˜•
export type Suit = 'major' | 'wands' | 'cups' | 'swords' | 'pentacles';
export type Element = 'fire' | 'water' | 'air' | 'earth' | null;
export type Category = 'general' | 'love' | 'career' | 'money' | 'health' | 'spiritual';
```

### ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥

```typescript
// ëŸ°íƒ€ì„ íƒ€ì… ì²´í¬
export class TarotError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'TarotError';
  }
}

export class CardNotFoundError extends TarotError {
  constructor(cardId: number) {
    super(`Card with ID ${cardId} not found`, 'CARD_NOT_FOUND');
  }
}
```

## ğŸš€ API ì„¤ê³„

### RESTful API ì›ì¹™

```typescript
// Express.js ë¼ìš°í„° êµ¬ì¡°
app.post('/api/reading/single', singleCardHandler);
app.post('/api/reading/three-card', threeCardHandler);
app.post('/api/reading/relationship', relationshipHandler);
app.post('/api/reading/celtic-cross', celticCrossHandler);
app.post('/api/analyze-question', questionAnalysisHandler);
app.get('/api/status', statusHandler);
```

### ì‘ë‹µ í˜•ì‹ í‘œì¤€í™”

```typescript
// ì„±ê³µ ì‘ë‹µ
interface SuccessResponse<T> {
  data: T;
  status: 'success';
  timestamp: string;
}

// ì—ëŸ¬ ì‘ë‹µ
interface ErrorResponse {
  error: string;
  details?: any;
  status: 'error';
  timestamp: string;
}
```

### ìš”ì²­/ì‘ë‹µ ê²€ì¦

```typescript
// ë¯¸ë“¤ì›¨ì–´ë¥¼ í†µí•œ ì…ë ¥ ê²€ì¦
app.use('/api/reading/*', validateReadingRequest);

function validateReadingRequest(req: Request, res: Response, next: NextFunction) {
  const { question } = req.body;
  if (!question || typeof question !== 'string') {
    return res.status(400).json({
      error: 'ì§ˆë¬¸ì€ í•„ìˆ˜ ì…ë ¥ ì‚¬í•­ì…ë‹ˆë‹¤',
      status: 'error'
    });
  }
  next();
}
```

## âš¡ ì„±ëŠ¥ ìµœì í™”

### 1. ë©”ëª¨ë¦¬ ê´€ë¦¬

```typescript
// ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í™•ë³´
export class CardLoader {
  private static instance: CardLoader;
  private allCards: TarotCard[] = []; // í•œ ë²ˆë§Œ ë¡œë“œ
  
  // ì§€ì—° ë¡œë”©
  public async loadAllCards(): Promise<void> {
    if (this.isLoaded) return; // ì¤‘ë³µ ë¡œë”© ë°©ì§€
    // ...
  }
}
```

### 2. ìºì‹± ì „ëµ

```typescript
// ì¡°í•© ê²°ê³¼ ìºì‹±
class CombinationCache {
  private cache = new Map<string, string>();
  
  public get(key: string): string | undefined {
    return this.cache.get(key);
  }
  
  public set(key: string, value: string): void {
    // LRU ìºì‹œ êµ¬í˜„
    if (this.cache.size > 1000) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

### 3. ë¹„ë™ê¸° ì²˜ë¦¬

```typescript
// Promise.allì„ ì´ìš©í•œ ë³‘ë ¬ ë¡œë”©
public async loadAllCards(): Promise<void> {
  const [majorData, wandsData, cupsData, swordsData, pentaclesData] = 
    await Promise.all([
      this.loadCardFile('/data/cards/majorArcana.json'),
      this.loadCardFile('/data/cards/wands.json'),
      this.loadCardFile('/data/cards/cups.json'),
      this.loadCardFile('/data/cards/swords.json'),
      this.loadCardFile('/data/cards/pentacles.json')
    ]);
}
```

### 4. ë²ˆë“¤ ìµœì í™”

```typescript
// ë™ì  importë¡œ ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…
const performDemo = async () => {
  const { TarotAppDemo } = await import('../demo/usage');
  await TarotAppDemo.runAllDemos();
};
```

## ğŸ”§ í™•ì¥ì„± ì„¤ê³„

### 1. í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜

```typescript
// í™•ì¥ ê°€ëŠ¥í•œ ìŠ¤í”„ë ˆë“œ ì‹œìŠ¤í…œ
interface SpreadStrategy {
  name: string;
  cardCount: number;
  positions: string[];
  interpret(cards: SelectedCard[]): string;
}

class CustomSpreadStrategy implements SpreadStrategy {
  name = 'custom-spread';
  cardCount = 7;
  positions = ['pos1', 'pos2', ...];
  
  interpret(cards: SelectedCard[]): string {
    // ì»¤ìŠ¤í…€ í•´ì„ ë¡œì§
    return 'Custom interpretation';
  }
}
```

### 2. ë‹¤êµ­ì–´ ì§€ì› ì¤€ë¹„

```typescript
// êµ­ì œí™” ì¤€ë¹„
interface LocalizedCard {
  [lang: string]: {
    name: string;
    interpretations: CardInterpretations;
    keywords: string[];
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
const card = {
  id: 0,
  localizations: {
    'ko': { name: 'ë°”ë³´', ... },
    'en': { name: 'The Fool', ... },
    'ja': { name: 'æ„šè€…', ... }
  }
};
```

### 3. ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ ì¤€ë¹„

```typescript
// Repository íŒ¨í„´ìœ¼ë¡œ ë°ì´í„° ì†ŒìŠ¤ ì¶”ìƒí™”
interface CardRepository {
  findById(id: number): Promise<TarotCard | null>;
  findAll(): Promise<TarotCard[]>;
  findBySuit(suit: Suit): Promise<TarotCard[]>;
}

class JSONCardRepository implements CardRepository {
  // JSON íŒŒì¼ ê¸°ë°˜ êµ¬í˜„
}

class DatabaseCardRepository implements CardRepository {
  // ë°ì´í„°ë² ì´ìŠ¤ ê¸°ë°˜ êµ¬í˜„ (í–¥í›„)
}
```

### 4. ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì¤€ë¹„

```typescript
// ì„œë¹„ìŠ¤ ë¶„ë¦¬ ì¤€ë¹„
interface ReadingService {
  performReading(request: ReadingRequest): Promise<Reading>;
}

interface AnalysisService {
  analyzeQuestion(question: string): Promise<QuestionAnalysis>;
}

interface CardService {
  getCard(id: number): Promise<TarotCard>;
  getRandomCards(count: number): Promise<TarotCard[]>;
}
```

## ğŸ›¡ï¸ ë³´ì•ˆ ë° ì—ëŸ¬ ì²˜ë¦¬

### 1. ì…ë ¥ ê²€ì¦

```typescript
// íƒ€ì… ê°€ë“œë¥¼ ì´ìš©í•œ ëŸ°íƒ€ì„ ê²€ì¦
function isValidCategory(category: any): category is Category {
  return ['general', 'love', 'career', 'money', 'health', 'spiritual']
    .includes(category);
}

// ì‚¬ìš©
if (!isValidCategory(req.body.category)) {
  throw new ValidationError('Invalid category');
}
```

### 2. ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ

```typescript
// ê³„ì¸µë³„ ì—ëŸ¬ ì²˜ë¦¬
class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
  }
}

// ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬
app.use((error: AppError, req: Request, res: Response, next: NextFunction) => {
  const { statusCode = 500, message } = error;
  
  res.status(statusCode).json({
    status: 'error',
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  });
});
```

### 3. ë¡œê¹… ì‹œìŠ¤í…œ

```typescript
// êµ¬ì¡°í™”ëœ ë¡œê¹…
interface LogEntry {
  timestamp: string;
  level: 'info' | 'warn' | 'error';
  message: string;
  context?: any;
}

class Logger {
  static info(message: string, context?: any) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      context
    }));
  }
}
```

## ğŸ“ˆ ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„

### 1. ì„±ëŠ¥ ë©”íŠ¸ë¦­

```typescript
// ì‘ë‹µ ì‹œê°„ ì¸¡ì •
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    Logger.info(`${req.method} ${req.path} - ${duration}ms`);
  });
  
  next();
});
```

### 2. ì‚¬ìš© í†µê³„

```typescript
// API í˜¸ì¶œ í†µê³„
interface ApiStats {
  endpoint: string;
  count: number;
  avgResponseTime: number;
  errorRate: number;
}

class StatsCollector {
  private stats = new Map<string, ApiStats>();
  
  record(endpoint: string, responseTime: number, isError: boolean) {
    // í†µê³„ ìˆ˜ì§‘ ë¡œì§
  }
}
```

## ğŸ”® ì•„í‚¤í…ì²˜ ì¥ì 

### 1. í™•ì¥ì„± (Scalability)
- ğŸ“ **ëª¨ë“ˆí™”ëœ êµ¬ì¡°**: ê° ì»´í¬ë„ŒíŠ¸ ë…ë¦½ì  í™•ì¥ ê°€ëŠ¥
- ğŸ”„ **ì‹±ê¸€í†¤ íŒ¨í„´**: ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
- ğŸ¯ **ì „ëµ íŒ¨í„´**: ìƒˆë¡œìš´ ìŠ¤í”„ë ˆë“œ ë°©ì‹ ì‰½ê²Œ ì¶”ê°€

### 2. ìœ ì§€ë³´ìˆ˜ì„± (Maintainability)
- ğŸ—ï¸ **ê³„ì¸µí˜• ì•„í‚¤í…ì²˜**: ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬
- ğŸ“ **ê°•íƒ€ì… ì‹œìŠ¤í…œ**: ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ ê°ì§€
- ğŸ§ª **í…ŒìŠ¤íŠ¸ ì¹œí™”ì **: ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ìš©ì´

### 3. ì„±ëŠ¥ (Performance)
- âš¡ **ì§€ì—° ë¡œë”©**: í•„ìš”í•œ ì‹œì ì—ë§Œ ë°ì´í„° ë¡œë“œ
- ğŸ’¾ **ë©”ëª¨ë¦¬ ìµœì í™”**: ì‹±ê¸€í†¤ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì†Œí™”
- ğŸ”„ **ë¹„ë™ê¸° ì²˜ë¦¬**: Promise.allë¡œ ë³‘ë ¬ ì²˜ë¦¬

### 4. ì•ˆì •ì„± (Reliability)
- ğŸ›¡ï¸ **íƒ€ì… ì•ˆì „ì„±**: TypeScriptë¡œ ëŸ°íƒ€ì„ ì—ëŸ¬ ë°©ì§€
- ğŸš¨ **ì—ëŸ¬ ì²˜ë¦¬**: ê³„ì¸µë³„ ì²´ê³„ì  ì—ëŸ¬ ê´€ë¦¬
- ğŸ“Š **ë¡œê¹… ì‹œìŠ¤í…œ**: ë¬¸ì œ ì¶”ì  ë° ë””ë²„ê¹… ì§€ì›

---

**ğŸ—ï¸ ì´ ì•„í‚¤í…ì²˜ëŠ” í˜„ì¬ 9ì¥ì˜ ì¹´ë“œë¡œ ì‹œì‘í•˜ì—¬ 78ì¥ ì™„ì„±ê¹Œì§€, ê·¸ë¦¬ê³  í–¥í›„ ëª¨ë°”ì¼ ì•±ê³¼ ê³ ê¸‰ AI ê¸°ëŠ¥ê¹Œì§€ í™•ì¥ ê°€ëŠ¥í•œ ê²¬ê³ í•œ ê¸°ë°˜ì„ ì œê³µí•©ë‹ˆë‹¤! ğŸ”®**